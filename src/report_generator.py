"""
Report Generator Module

This module handles the generation of final performance review reports,
including conversion between markdown and DOCX formats.
"""

import os
from datetime import datetime
import json
from docx import Document
import markdown
from markdown.extensions import fenced_code, tables

def load_template(review_type):
    """
    Load the appropriate review template.
    
    Args:
        review_type (str): Type of review ('annual' or 'competency')
        
    Returns:
        str: The template content
        
    Raises:
        FileNotFoundError: If the template file does not exist
    """
    template_path = f"templates/{review_type}_review_template.md"
    if not os.path.exists(template_path):
        raise FileNotFoundError(f"Template file not found: {template_path}")
        
    with open(template_path, 'r', encoding='utf-8') as f:
        return f.read()

def load_analysis(file_path):
    """
    Load the analysis generated by Roo Code.
    
    Args:
        file_path (str): Path to the analysis file (should be data/analyzed_[type].md)
        
    Returns:
        str: The analyzed content
        
    Raises:
        FileNotFoundError: If the analysis file doesn't exist, indicating Roo Code analysis hasn't been done
    """
    analysis_path = file_path.replace('processed_', 'analyzed_').replace('.json', '.md')
    
    if not os.path.exists(analysis_path):
        raise FileNotFoundError(
            f"Analysis file not found: {analysis_path}\n\n"
            "Please complete these steps first:\n"
            "1. Open VS Code\n"
            "2. Switch to Performance Analyst mode\n"
            f"3. Use the command: @{file_path} Please analyze this data and generate a structured report\n"
            "4. Save Roo Code's analysis to: " + analysis_path
        )
        
    with open(analysis_path, 'r', encoding='utf-8') as f:
        return f.read()

def markdown_to_docx(markdown_text, output_path):
    """
    Convert markdown formatted text to a DOCX document.
    
    Args:
        markdown_text (str): The markdown formatted text to convert
        output_path (str): Path where the DOCX file should be saved
        
    Returns:
        str: Path to the generated DOCX file
        
    Raises:
        ValueError: If the markdown text is empty
    """
    if not markdown_text.strip():
        raise ValueError("Markdown text cannot be empty")
    
    # Create new Document
    doc = Document()
    
    # Process markdown line by line
    in_list = False
    lines = markdown_text.split('\n')
    
    for line in lines:
        line = line.rstrip()
        if not line:
            # Empty line
            continue
            
        # Check for headers
        if line.startswith('# '):
            doc.add_heading(line[2:], level=1)
        elif line.startswith('## '):
            doc.add_heading(line[3:], level=2)
        elif line.startswith('### '):
            doc.add_heading(line[4:], level=3)
        # Check for list items
        elif line.startswith('- '):
            if not in_list:
                in_list = True
            doc.add_paragraph(line[2:], style='List Bullet')
        # Regular paragraph
        else:
            in_list = False
            doc.add_paragraph(line)
    
    # Save the document
    doc.save(output_path)
    return output_path

def generate_final_report(data_file, review_type, output_format='markdown', output_path=None):
    """
    Generate final formatted report by combining Roo Code analysis with template.
    
    Args:
        data_file (str): Path to the processed JSON data file
        review_type (str): Type of review ('annual' or 'competency')
        output_format (str): Output format ('markdown' or 'docx')
        output_path (str, optional): Path for the output file
        
    Returns:
        str: Path to the generated report file
        
    Raises:
        FileNotFoundError: If required files are not found
        ValueError: If inputs are invalid
    """
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    
    # If no output path is specified, create a default one
    if not output_path:
        output_path = f"output/{review_type.lower()}_review_{timestamp}.{'md' if output_format.lower() == 'markdown' else 'docx'}"
    
    # Ensure the output directory exists
    output_dir = os.path.dirname(output_path)
    if output_dir:
        os.makedirs(output_dir, exist_ok=True)
    
    try:
        # Load Roo Code's analysis
        analyzed_content = load_analysis(data_file)
        
        # Load and apply the template
        template = load_template(review_type)
        report_content = template.format(analyzed_content=analyzed_content)
        
        if output_format.lower() == 'markdown':
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(report_content)
        elif output_format.lower() == 'docx':
            # If output path is for a docx, but we need a temporary md file
            if output_path.endswith('.docx'):
                md_path = output_path.replace('.docx', '.md')
            else:
                md_path = f"{output_path}.md"
                
            # Save markdown version
            with open(md_path, 'w', encoding='utf-8') as f:
                f.write(report_content)
                
            # Convert to DOCX
            docx_path = output_path if output_path.endswith('.docx') else f"{output_path}.docx"
            markdown_to_docx(report_content, docx_path)
            output_path = docx_path
            
            # Clean up temporary markdown file if it was just for conversion
            if md_path != output_path and os.path.exists(md_path):
                os.remove(md_path)
    
    except NotImplementedError as e:
        # Pass through the Roo Code usage instructions
        raise NotImplementedError(str(e))
    except Exception as e:
        raise ValueError(f"Error generating report: {str(e)}")

    return output_path

def main():
    """Command line interface for the report generator."""
    import argparse
    
    parser = argparse.ArgumentParser(
        description='Generate final performance review report',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    Generate an annual review report:
    %(prog)s --input data/processed_annual.json --type annual --format docx

    Generate a competency assessment report:
    %(prog)s --input data/processed_competency.json --type competency --format markdown
        """
    )
    
    parser.add_argument('--input', required=True, 
                       help='Path to processed JSON data file')
    parser.add_argument('--type', required=True, 
                       choices=['annual', 'competency'],
                       help='Type of review')
    parser.add_argument('--format', default='markdown', 
                       choices=['markdown', 'docx'],
                       help='Output format (default: markdown)')
    parser.add_argument('--output',
                       help='Output file path for the generated report')
    
    args = parser.parse_args()
    
    try:
        # Generate report from processed data
        output_path = generate_final_report(
            args.input,  # Now passing the data file path
            args.type, 
            args.format,
            args.output
        )
        
        print(f"Report generated successfully at: {output_path}")
        print("\nNote: If this is your first time generating a report, you'll need to:")
        print("1. Open VS Code")
        print("2. Switch to Performance Analyst mode")
        print(f"3. Use the command: @{args.input} Please analyze this data for my {args.type} review")
        print("4. Once Roo Code generates the analysis, run this command again")
        
    except NotImplementedError as e:
        print(str(e))
        return 1
    except Exception as e:
        print(f"Error generating report: {str(e)}")
        return 1
    
    return 0

if __name__ == "__main__":
    exit(main())